///////////////////////////////////////////////////////////////////////////////
//FILE: 'rcs.cpp'
//Contains 'rcs' module of class 'Hyper'
//
//040302 Created by Peter H Zipfel
///////////////////////////////////////////////////////////////////////////////

#include "class_hierarchy.hpp"

///////////////////////////////////////////////////////////////////////////////
//Definition of RCS thruster module-variables 
//Member function of class 'Hyper'
//Module-variable locations are assigned to hyper[50-99]
//
// mrcs_moment = |rcs_type||rcs_mode|
//
//			      rcs_type = 0 no RCS thrusting
//					       = 1 proportional moment thrusters
//						   = 2 on-off moment thrusters (Schmitt trigger)
//
//			    		    rcs_mode = 0 no control
//								     = 1 all angle control
//								     = 2 thrust vector direction and roll angle control
//
// mrcs_force = 0 no side force control
//			  = 1 proportional side thrusters
//
//040302 Created by Peter H Zipfel
///////////////////////////////////////////////////////////////////////////////

void Hyper::def_rcs()
{
	//Definition and initialization of module-variables
	hyper[50].init("mrcs_moment","int",0,"Attitude control, =|rcs_type||rcs_mode|, see table","rcs","data","");
	hyper[51].init("mrcs_force","int",0,"Side force control =0: none; =1:prop.; =2:Schmitt","rcs","data","");
	hyper[52].init("dead_zone",0,"Dead zone of Schmitt trigger - mixed","rcs","data","");
	hyper[53].init("hysteresis",0,"Hysteresis of Schmitt trigger - mixed","rcs","data","");
	hyper[54].init("rcs_tau",0,"Slope of the switching function - sec","rcs","data","");
	hyper[55].init("roll_mom_max",0,"RCS rolling moment max value - Nm","rcs","data","");
	hyper[56].init("pitch_mom_max",0,"RCS pitching moment max value - Nm","rcs","data","");
	hyper[57].init("yaw_mom_max",0,"RCS yawing moment max value - Nm","rcs","data","");
	hyper[58].init("rcs_zeta",0,"Damping of closed-loop prop RCS - ND","rcs","data","");
	hyper[59].init("rcs_freq",0,"Natural freq. of closed-loop prop RCS - rad/s","rcs","data","");
	hyper[61].init("roll_save",0,"Saving roll angle command - deg","rcs","save","");
	hyper[62].init("pitch_save",0,"Saving pitch angle command - deg","rcs","save","");
	hyper[63].init("yaw_save",0,"Saving yaw angle command - deg","rcs","save","");
	hyper[64].init("FMRCS",0,0,0,"Moment generated by the RCS thrusters - Nm","rcs","out","");
	hyper[70].init("phibdcomx",0,"Roll angle command - deg","rcs","data","");
	hyper[71].init("thtbdcomx",0,"Pitch angle command - deg","rcs","data","");
	hyper[72].init("psibdcomx",0,"Yaw angle command - deg","rcs","data","");
	hyper[73].init("e_roll",0,"Roll error signal - mixed","rcs","diag","");
	hyper[74].init("e_pitch",0,"Pitch error signal - mixed","rcs","diag","");
	hyper[75].init("e_yaw",0,"Yaw error signal - mixed","rcs","diag","");
	hyper[76].init("o_roll","int",0,"Roll output of Schmitt trigger - +/-1","rcs","save","");
	hyper[77].init("o_pitch","int",0,"Pitch output of Schmitt trigger - +/-1","rcs","save","");
	hyper[78].init("o_yaw","int",0,"Yaw output of Schmitt trigger - +/-1","rcs","save","");
	hyper[79].init("roll_count","int",0,"Roll thruster on/off - ND","rcs","save","plot");
	hyper[80].init("pitch_count","int",0,"Pitch thruster on/off - ND","rcs","save","plot");
	hyper[81].init("yaw_count","int",0,"Yaw thruster on/off - ND","rcs","save","plot");
	hyper[83].init("side_force_max",0,"Maximum side force of thruster - N","rcs","data","");
	hyper[84].init("FARCS",0,0,0,"Force generated by the RCS side thrusters - N","rcs","out","");
	hyper[85].init("e_right",0,"Side force error signal, right - N","rcs","diag","");
	hyper[86].init("e_down",0,"Down force error signal, down - N","rcs","diag","");
	hyper[87].init("o_right","int",0,"Right output of Schmitt trigger - +/-1","rcs","save","");
	hyper[88].init("o_down","int",0,"Down output of Schmitt trigger - +/-1","rcs","save","");
	hyper[89].init("right_save",0,"Saving right force command - N","rcs","save","");
	hyper[90].init("down_save",0,"Saving down force command - N","rcs","save","");
	hyper[93].init("rcs_minit_flag","int",1,"Initialization flag for Euler yaw angle command","rcs","init","");
}	

///////////////////////////////////////////////////////////////////////////////
//RCS thruster module
//Member function of class 'Hyper'
// Calls thrusters dynamic subroutine
//
// mrcs_moment = |rcs_type||rcs_mode|
//
//			      rcs_type = 0 no RCS thrusting
//					       = 1 proportional moment thrusters
//						   = 2 on-off moment thrusters (Schmitt trigger)
//
//			    		    rcs_mode = 0 no control
//								     = 1 all angle control
//								     = 2 thrust vector direction and roll angle control
//
// mrcs_force = 0 no side force control
//			  = 1 proportional side thrusters
//
// For automated mission planning ('minit=1'), when the RCS is on angle control,
//  i.e., 'rcs_mode==1'(pull-up phase),
//  the initial Euler yaw angle is held as commanded by 'psibdcomx'  
//
//040302 Created by Peter H Zipfel
///////////////////////////////////////////////////////////////////////////////

void Hyper::rcs()
{
	//local variables

	//local module-variables
	double e_roll(0);
	double e_pitch(0);
	double e_yaw(0);
	double e_right(0);
	double e_down(0);
	Matrix FMRCS(3,1);
	Matrix FARCS(3,1);

	//localizing module-variables
	//input data
	int mrcs_moment=hyper[50].integer();
	int mrcs_force=hyper[51].integer();
	double dead_zone=hyper[52].real();
	double hysteresis=hyper[53].real();
	double rcs_tau=hyper[54].real();
	double roll_mom_max=hyper[55].real();
	double pitch_mom_max=hyper[56].real();
	double yaw_mom_max=hyper[57].real();
	double rcs_zeta=hyper[58].real();
	double rcs_freq=hyper[59].real();
	double phibdcomx=hyper[70].real();
	double thtbdcomx=hyper[71].real();
	double psibdcomx=hyper[72].real();
	double side_force_max=hyper[83].real();
	//initialization
	int rcs_minit_flag=hyper[93].integer();
	//input from other modules
	double time=round6[0].real();
	int minit=round6[210].integer();
	double vmass=hyper[15].real();
	Matrix IBBB=hyper[18].mat();
	double ppcx=hyper[320].real();
	double qqcx=hyper[321].real();
	double rrcx=hyper[322].real();
	double psivdcx=hyper[333].real();
	Matrix FSPCB=hyper[334].vec();
	double phibdcx=hyper[338].real();
	double thtbdcx=hyper[339].real();
	double psibdcx=hyper[340].real();
	double aycomx=hyper[421].real();
	double azcomx=hyper[422].real();
	Matrix UTBC=hyper[430].vec();
	int beco_flag=hyper[432].integer();  
	//reloading saved values
	double roll_save=hyper[61].real();
	double pitch_save=hyper[62].real();
	double yaw_save=hyper[63].real();
	int o_roll=hyper[76].integer();
	int o_pitch=hyper[77].integer();
	int o_yaw=hyper[78].integer();
	int roll_count=hyper[79].integer();
	int pitch_count=hyper[80].integer();
	int yaw_count=hyper[81].integer();
	int o_right=hyper[87].integer();
	int o_down=hyper[88].integer();
	double right_save=hyper[89].real();
	double down_save=hyper[90].real();
	//-------------------------------------------------------------------------
	//decoding rcs_mom flag
    int rcs_type=mrcs_moment/10;
    int rcs_mode=(mrcs_moment%10);
	
	//for automatic mission planning hold 'psibdcomx'to intial 'psibdcx' value
	//   when RCS povides angle control
	if(minit&&rcs_mode==1&&(rcs_minit_flag||beco_flag)){
		rcs_minit_flag=0;
		psibdcomx=psivdcx;
	}
	//proportional moment thrusters
	if(rcs_type==1){

		//gain calculations
		double rgain_roll=2*rcs_zeta*rcs_freq*IBBB.get_loc(0,0);
		double rgain_pitch=2*rcs_zeta*rcs_freq*IBBB.get_loc(1,1);
		double rgain_yaw=2*rcs_zeta*rcs_freq*IBBB.get_loc(2,2);
		double pgain=rcs_freq/(2*rcs_zeta);

		//roll angle control (always) 
		e_roll=rgain_roll*(pgain*(phibdcomx-phibdcx)-ppcx);
		FMRCS[0]=rcs_prop(e_roll,roll_mom_max);

		//angle control
		if(rcs_mode==1){
			e_pitch=rgain_pitch*(pgain*(thtbdcomx-thtbdcx)-qqcx);
			e_yaw=rgain_yaw*(pgain*(psibdcomx-psibdcx)-rrcx);
		}
		//vector directional control
		else if(rcs_mode==2){
			e_pitch=rgain_pitch*(pgain*(-UTBC[2])*DEG-qqcx);//DEG is used, because all angle var. are in deg
			e_yaw=rgain_yaw*(pgain*(UTBC[1])*DEG-rrcx);
		}

		//moments generated about the two transverse principle axes wrt the c.m
		FMRCS[1]=rcs_prop(e_pitch,pitch_mom_max);
		FMRCS[2]=rcs_prop(e_yaw,yaw_mom_max);
	}

	//Proportional side force thrusters
	if(mrcs_force==1){

		//acceleration control
		e_right=vmass*aycomx*AGRAV;
		FARCS[1]=rcs_prop(e_right,side_force_max);

		e_down=vmass*azcomx*AGRAV;
		FARCS[2]=rcs_prop(e_down,side_force_max);
	}

	//on-off moment thrusters (Schmitt trigger)
	if(rcs_type==2){

		//roll angle control (always)
		e_roll=phibdcomx-(rcs_tau*ppcx+phibdcx);
		//on/off output of Schmitt trigger
		int o_roll_save=o_roll;
		o_roll=rcs_schmitt(e_roll,roll_save,dead_zone,hysteresis);
		roll_save=e_roll;
		if(o_roll!=o_roll_save)roll_count++;

		//angle control
		if(rcs_mode==1){
			e_pitch=thtbdcomx-(rcs_tau*qqcx+thtbdcx);
			e_yaw=psibdcomx-(rcs_tau*rrcx+psibdcx);
		}
		//vector directional control
		else if(rcs_mode==2){
			e_pitch=-rcs_tau*qqcx-UTBC[2]*DEG;
			e_yaw=-rcs_tau*rrcx+UTBC[1]*DEG;
		}
		int o_pitch_save=o_pitch;
		o_pitch=rcs_schmitt(e_pitch,pitch_save,dead_zone,hysteresis);
		pitch_save=e_pitch;
		if(o_pitch!=o_pitch_save)pitch_count++;

		int o_yaw_save=o_yaw;
		o_yaw=rcs_schmitt(e_yaw,yaw_save,dead_zone,hysteresis);
		yaw_save=e_yaw;
		if(o_yaw!=o_yaw_save)yaw_count++;

		//moments generated about the three principle axes wrt the c.m
		FMRCS[0]=o_roll*roll_mom_max;
		FMRCS[1]=o_pitch*pitch_mom_max;
		FMRCS[2]=o_yaw*yaw_mom_max;
	}
	//-------------------------------------------------------------------------
	//loading module-variables
	//output to other modules
	hyper[64].gets_vec(FMRCS);
	hyper[84].gets_vec(FARCS);
	//saving values for next cycle
	hyper[61].gets(roll_save);
	hyper[62].gets(pitch_save);
	hyper[63].gets(yaw_save);
	hyper[72].gets(psibdcomx);
	hyper[76].gets(o_roll);
	hyper[77].gets(o_pitch);
	hyper[78].gets(o_yaw);
	hyper[79].gets(roll_count);
	hyper[80].gets(pitch_count);
	hyper[81].gets(yaw_count);
	hyper[87].gets(o_right);
	hyper[88].gets(o_down);
	hyper[89].gets(right_save);
	hyper[90].gets(down_save);
	hyper[93].gets(rcs_minit_flag);
	//diagnostics
	hyper[73].gets(e_roll);
	hyper[74].gets(e_pitch);
	hyper[75].gets(e_yaw);
	hyper[85].gets(e_right);
	hyper[86].gets(e_down);
}
	
///////////////////////////////////////////////////////////////////////////////
//Proportional thrusters with limiters
//Member function of class 'Hyper'
//
// parameter input
//		input = commanded input - Nm
//		limiter = max and min value of applied moment - Nm
// return output
//		output = moment about principle axis through c.m. - Nm
//
//040309 Created by Peter H Zipfel
///////////////////////////////////////////////////////////////////////////////

double Hyper::rcs_prop(double input,double limiter)
{	
	//local variable
	double output(0);
	output=input;
	if(fabs(input)>limiter)
		output=limiter*sign(input);

	return output;
}

///////////////////////////////////////////////////////////////////////////////
//On-off thrusters modeled by the Schmitt trigger
//Ref: Bryson,A.E.,"Control of Spacecraft and Aircraft", Princeton University Press, 1994
//Switching mechanism with dead-zone and hysteresis, includes also pure hysteresis (dead_zone=0)
// pure dead-zone (hysteresis=0), or simple on/off relay (dead_zone=0,hysteresis=0)
//Member function of class 'Hyper'
//
// parameter input
//		input_new = new input value, state variable
//		input = previous input value, saved state variable
//		dead_zone = dead zone of trigger, if zero -> pure hysteresis - units of input
//		hysteresis = hysteresis, if zero -> pure dead zone - units of input
// return output
//		=+/-1: trigger on; =0 trigger off 
//
//040308 Created by Peter H Zipfel
///////////////////////////////////////////////////////////////////////////////

int Hyper::rcs_schmitt(double input_new,double input,double dead_zone,double hysteresis)
{	
	//local variable
	int output(0);

	//input signal 'trend' (=1 increasing, =-1 decreasing)
	//input signal 'side' (=-1 left, =1 right)
	int trend=sign(input_new-input);
	int side=sign(input);
	double trigger=(dead_zone*side+hysteresis*trend)/2;

	if(input>=trigger&&side==1){
		output=1;
	}
	else if(input<=trigger&&side==-1){
		output=-1;
	}
	else
		output=0;

	return output;
}