///////////////////////////////////////////////////////////////////////////////
//FILE: 'rcs.cpp'
//Contains 'rcs' module of class 'Missile'
//
//040302 Created by Peter H Zipfel
//081010 Adapted for GENSIM6, PZi
///////////////////////////////////////////////////////////////////////////////

#include "class_hierarchy.hpp"

using namespace std;

///////////////////////////////////////////////////////////////////////////////
//Definition of RCS thruster module-variables 
//Member function of class 'Missile'
//Module-variable locations are assigned to missile[50-99]
//
// mrcs_moment = |rcs_type||rcs_mode|
//
//			      rcs_type = 0 no RCS thrusting
//					       = 1 proportional moment thrusters
//						   = 2 on-off moment thrusters (Schmitt trigger)
//
//			    		    rcs_mode = 0 roll control only
//								     = 1 all geodetic Euler angle control
//								     = 2 thrust vector direction and roll angle control
//								     = 3 incidence and roll angle control
//									 = 4 rate damping
//
// mrcs_force = 0 no side force control
//			  = 1 proportional side thrusters
//			  = 2 on-off side thrusters (Schmitt trigger)
//
//040302 Created by Peter H Zipfel
//080328 Added rate damping option, PZi
//081010 Adapted for GENSIM6, PZi
///////////////////////////////////////////////////////////////////////////////

void Missile::def_rcs()
{
	//Definition and initialization of module-variables
	missile[50].init("mrcs_moment","int",0,"Attitude control, =|rcs_type||rcs_mode|, see table","rcs","data","");
	missile[51].init("mrcs_force","int",0,"Side force control =0: none; =1:prop.; =2:Schmitt","rcs","data","");
	missile[52].init("dead_zone",0,"Dead zone of Schmitt trigger - m/s^2","rcs","data","");
	missile[53].init("hysteresis",0,"Hysteresis of Schmitt trigger - m/s^2","rcs","data","");
	missile[54].init("rcs_tau",0,"Slope of the switching function - sec","rcs","data","");
	missile[55].init("roll_mom_max",0,"RCS rolling moment max value - Nm","rcs","data","");
	missile[56].init("pitch_mom_max",0,"RCS pitching moment max value - Nm","rcs","data","");
	missile[57].init("yaw_mom_max",0,"RCS yawing moment max value - Nm","rcs","data","");
	missile[58].init("rcs_zeta",0,"Damping of closed-loop rop RCS - ND","rcs","data","");
	missile[59].init("rcs_freq",0,"Natural freq. of closed-loop prop RCS - rad/s","rcs","data","");
	missile[60].init("rcs_arm",0,"RCS location from tip of missile - m","rcs","data","");
	missile[61].init("roll_save",0,"Saving roll angle command - deg","rcs","save","");
	missile[62].init("pitch_save",0,"Saving pitch angle command - deg","rcs","save","");
	missile[63].init("yaw_save",0,"Saving yaw angle command - deg","rcs","save","");
	missile[64].init("FMRCS",0,0,0,"Moment generated by the RCS thrusters - Nm","rcs","out","");
	missile[65].init("rcs_time",0,"Total burn time of all nozzles - s","rcs","save","");
	missile[66].init("rcs_isp",0,"RCS specific impulse - s","rcs","data","");
	missile[67].init("rcs_fmass",0,"RCS fuel mass expended - kg","rcs","out","");
	missile[68].init("rate_gain_rcs",0,"RCS gain for damping augmentation - Nm/(deg*sec)","rcs","data","");

	missile[70].init("phibdcomx",0,"Roll angle command - deg","rcs","data","");
	missile[71].init("thtbdcomx",0,"Pitch angle command - deg","rcs","data","");
	missile[72].init("psibdcomx",0,"Yaw angle command - deg","rcs","data","");
	missile[73].init("e_roll",0,"Roll error signal - mixed","rcs","diag","");
	missile[74].init("e_pitch",0,"Pitch error signal - mixed","rcs","diag","");
	missile[75].init("e_yaw",0,"Yaw error signal - mixed","rcs","diag","");
	missile[76].init("o_roll","int",0,"Roll output of Schmitt trigger - +/-1","rcs","save","");
	missile[77].init("o_pitch","int",0,"Pitch output of Schmitt trigger - +/-1","rcs","save","");
	missile[78].init("o_yaw","int",0,"Yaw output of Schmitt trigger - +/-1","rcs","save","");
	missile[79].init("roll_count","int",0,"Roll thruster on/off - ND","rcs","save","");
	missile[80].init("pitch_count","int",0,"Pitch thruster on/off - ND","rcs","save","");
	missile[81].init("yaw_count","int",0,"Yaw thruster on/off - ND","rcs","save","");
	missile[82].init("acc_gain",0,"Acceleration gain of side thrusters - N/(m/s^2)","rcs","data","");
	missile[83].init("rcs_thrust",0,"Maximum side force of thruster - N","rcs","data","");
	missile[84].init("FARCS",0,0,0,"Force generated by the RCS side thrusters - N","rcs","out","");
	missile[85].init("e_right",0,"Side force error signal, right - N","rcs","diag","");
	missile[86].init("e_down",0,"Down force error signal, down - N","rcs","diag","");
	missile[87].init("o_right","int",0,"Right output of Schmitt trigger - +/-1","rcs","save","");
	missile[88].init("o_down","int",0,"Down output of Schmitt trigger - +/-1","rcs","save","");
	missile[89].init("right_save",0,"Saving right force command - N","rcs","save","");
	missile[90].init("down_save",0,"Saving down force command - N","rcs","save","");
	missile[91].init("right_count","int",0,"Right force thruster on/off - ND","rcs","save","");
	missile[92].init("down_count","int",0,"Down forece thruster on/off - ND","rcs","save","");
	missile[93].init("factdead_zone",0,"Factor to mod 'dead_zone' dead_zone*(1+factdead_zone) - ND","rcs","save","");
}	
///////////////////////////////////////////////////////////////////////////////
//RCS thruster module
//Member function of class 'Missile'
// Calls thrusters dynamic subroutine
//
// mrcs_moment = |rcs_type||rcs_mode|
//
//			      rcs_type = 0 no RCS thrusting
//					       = 1 proportional moment thrusters
//						   = 2 on-off moment thrusters (Schmitt trigger)
//
//			    		    rcs_mode = 0 roll control only
//								     = 1 all geodetic Euler angle control
//								     = 2 thrust vector direction and roll angle control
//								     = 3 incidence and roll angle control
//									 = 4 rate damping
//
// mrcs_force = 0 no side force control
//			  = 1 proportional side thrusters
//			  = 2 on-off side thrusters (Schmitt trigger)
//
//040302 Created by Peter H Zipfel
//080328 Added rate damping option, PZi
//081010 Adapted for GENSIM6, PZi
///////////////////////////////////////////////////////////////////////////////

void Missile::rcs(double int_step)
{
	//local variables
	double pgain(0);

	//local module-variables
	double e_roll(0);
	double e_pitch(0);
	double e_yaw(0);
	double e_right(0);
	double e_down(0);
	Matrix FMRCS(3,1);
	Matrix FARCS(3,1);
	double rcs_fmass(0);

	//localizing module-variables
	//input data
	int mrcs_moment=missile[50].integer();
	int mrcs_force=missile[51].integer();
	double dead_zone=missile[52].real();
	double hysteresis=missile[53].real();
	double rcs_tau=missile[54].real();
	double roll_mom_max=missile[55].real();
	double pitch_mom_max=missile[56].real();
	double yaw_mom_max=missile[57].real();
	double rcs_zeta=missile[58].real();
	double rcs_freq=missile[59].real();
	double rcs_arm=missile[60].real();
	double rcs_isp=missile[66].real();
	double rate_gain_rcs=missile[68].real();
	double phibdcomx=missile[70].real();
	double thtbdcomx=missile[71].real();
	double psibdcomx=missile[72].real();
	double acc_gain=missile[82].real();
	double rcs_thrust=missile[83].real();
	double factdead_zone=missile[93].real();
	//input from other modules
	double pdynmc=flat6[57].real();
	double xcg=missile[15].real();
	double ai11=missile[16].real();
	double ai33=missile[17].real();
	Matrix WBECB=missile[306].vec(); 
	double thtblcx=missile[329].real();
	Matrix FSPCB=missile[334].vec();
	double phiblcx=missile[335].real();
	double alphacx=missile[336].real();
	double betacx=missile[337].real();
	double psibdcx=missile[340].real();
	double ancomx=missile[402].real();
	double alcomx=missile[403].real();
	Matrix UTBC=missile[430].vec();
	double alphacomx=missile[481].real();
	double betacomx=missile[482].real();
	//reloading saved values
	double roll_save=missile[61].real();
	double pitch_save=missile[62].real();
	double yaw_save=missile[63].real();
	double rcs_time=missile[65].real();
	int o_roll=missile[76].integer();
	int o_pitch=missile[77].integer();
	int o_yaw=missile[78].integer();
	int roll_count=missile[79].integer();
	int pitch_count=missile[80].integer();
	int yaw_count=missile[81].integer();
	int o_right=missile[87].integer();
	int o_down=missile[88].integer();
	double right_save=missile[89].real();
	double down_save=missile[90].real();
	int right_count=missile[91].integer();
	int down_count=missile[92].integer();
	//-------------------------------------------------------------------------
	//decoding rcs_mom flag
    int rcs_type=mrcs_moment/10;
    int rcs_mode=(mrcs_moment%10);

	//decomposing measured body rates
	double ppcx=WBECB[0];
	double qqcx=WBECB[1];
	double rrcx=WBECB[2];
	
	//proportional moment thrusters
	if(rcs_type==1){

		//gain calculations
		double rgain_roll=2*rcs_zeta*rcs_freq*ai11;
		double rgain_pitch=2*rcs_zeta*rcs_freq*ai33;
		double rgain_yaw=2*rcs_zeta*rcs_freq*ai33;
		if(rcs_zeta)
			pgain=rcs_freq/(2*rcs_zeta);

		//roll angle control (always) 
		e_roll=rgain_roll*(pgain*(phibdcomx-phiblcx)-ppcx);
		FMRCS[0]=rcs_prop(e_roll,roll_mom_max);

		//geodetic Euler angle control
		if(rcs_mode==1){
			e_pitch=rgain_pitch*(pgain*(thtbdcomx-thtblcx)-qqcx);
			e_yaw=rgain_yaw*(pgain*(psibdcomx-psibdcx)-rrcx);
		}
		//vector directional control
		else if(rcs_mode==2){
			e_pitch=rgain_pitch*(pgain*(-UTBC[2])*DEG-qqcx);//DEG is used, because all angle var. are in deg
			e_yaw=rgain_yaw*(pgain*(UTBC[1])*DEG-rrcx);
		}
		//rate damping
		else if(rcs_mode==4){
			e_pitch=rate_gain_rcs*(-qqcx);
			e_yaw=rate_gain_rcs*(-rrcx);
		}
		//moments generated about the two transverse principle axes wrt the c.m
		FMRCS[1]=rcs_prop(e_pitch,pitch_mom_max);
		FMRCS[2]=rcs_prop(e_yaw,yaw_mom_max);
	}
	//Proportional side force thrusters
	if(mrcs_force==1){

		//acceleration control
		double ay=FSPCB[1];
		e_right=acc_gain*(alcomx*AGRAV-ay);
		FARCS[1]=rcs_prop(e_right,rcs_thrust);

		double az=FSPCB[2];
		e_down=-acc_gain*(ancomx*AGRAV+az);
		FARCS[2]=rcs_prop(e_down,rcs_thrust);
	}
	//on-off moment thrusters (Schmitt trigger)

	if(rcs_type==2){
		//roll angle control (always)
		e_roll=phibdcomx-(rcs_tau*ppcx+phiblcx);
		//on/off output of Schmitt trigger
		int o_roll_save=o_roll;
		o_roll=rcs_schmitt(e_roll,roll_save,dead_zone,hysteresis);
		roll_save=e_roll;
		if(o_roll!=o_roll_save)
			roll_count++;

		//Euler angle control
		if(rcs_mode==1){
			e_pitch=thtbdcomx-(rcs_tau*qqcx+thtblcx);
			e_yaw=psibdcomx-(rcs_tau*rrcx+psibdcx);
		}
		//incidence angle control
		if(rcs_mode==3){
			e_pitch=alphacomx-(rcs_tau*qqcx+alphacx);
			e_yaw=-betacomx-(rcs_tau*rrcx-betacx);
		}
		//vector directional control
		else if(rcs_mode==2){
			e_pitch=-rcs_tau*qqcx-UTBC[2]*DEG;
			e_yaw=-rcs_tau*rrcx+UTBC[1]*DEG;
		}
		//rate damping
		else if(rcs_mode==4){
			e_pitch=-rcs_tau*qqcx;
			e_yaw=-rcs_tau*rrcx;
		}

		int o_pitch_save=o_pitch;
		o_pitch=rcs_schmitt(e_pitch,pitch_save,dead_zone,hysteresis);
		pitch_save=e_pitch;
		if(o_pitch!=o_pitch_save)pitch_count++;

		int o_yaw_save=o_yaw;
		o_yaw=rcs_schmitt(e_yaw,yaw_save,dead_zone,hysteresis);
		yaw_save=e_yaw;
		if(o_yaw!=o_yaw_save)yaw_count++;

		//moments generated about the three principle axes wrt the c.m
		FMRCS[0]=o_roll*roll_mom_max;
		FMRCS[1]=o_pitch*pitch_mom_max;
		FMRCS[2]=o_yaw*yaw_mom_max;
	}

	//on-off side force thrusters (Schmitt trigger)
	if(mrcs_force==2){

		//acceleration control
		double ay=FSPCB[1];
		e_right=acc_gain*(alcomx*AGRAV-ay);

		int o_right_save=o_right;
		o_right=rcs_schmitt(e_right,right_save,dead_zone,hysteresis);
		right_save=e_right;
		if(o_right!=o_right_save)right_count++;

		double az=FSPCB[2];
		e_down=-acc_gain*(ancomx*AGRAV+az);
		int o_down_save=o_down;
		o_down=rcs_schmitt(e_down,down_save,dead_zone,hysteresis);
		down_save=e_down;
		if(o_down!=o_down_save)down_count++;

		//RCS force components in body coord
		FARCS[0]=0;
		FARCS[1]=o_right*rcs_thrust;
		FARCS[2]=o_down*rcs_thrust;

		//RCS parasitic moment components in body coord
		double dx=rcs_arm-xcg;
		FMRCS[1]=FARCS[2]*dx;
		FMRCS[2]=-FARCS[1]*dx;

		//fuel consumption
		//time of down/up rcs nozzle 'on'
		if(o_down){
			rcs_time+=int_step;
		}
		//plus time of right/left rcs nozzle 'on'
		if(o_right){
			rcs_time+=int_step;
		}
		//fuel mass
		rcs_fmass=rcs_thrust*rcs_time/(rcs_isp*AGRAV);
	}
	//-------------------------------------------------------------------------
	//loading module-variables
	//output to other modules
	missile[64].gets_vec(FMRCS);
	missile[67].gets(rcs_fmass);
	missile[84].gets_vec(FARCS);
	//saving values for next cycle
	missile[61].gets(roll_save);
	missile[62].gets(pitch_save);
	missile[63].gets(yaw_save);
	missile[65].gets(rcs_time);
	missile[72].gets(psibdcomx);
	missile[76].gets(o_roll);
	missile[77].gets(o_pitch);
	missile[78].gets(o_yaw);
	missile[79].gets(roll_count);
	missile[80].gets(pitch_count);
	missile[81].gets(yaw_count);
	missile[87].gets(o_right);
	missile[88].gets(o_down);
	missile[89].gets(right_save);
	missile[90].gets(down_save);
	missile[91].gets(right_count);
	missile[92].gets(down_count);
	//diagnostics
	missile[52].gets(dead_zone);
	missile[73].gets(e_roll);
	missile[74].gets(e_pitch);
	missile[75].gets(e_yaw);
	missile[85].gets(e_right);
	missile[86].gets(e_down);
}
	
///////////////////////////////////////////////////////////////////////////////
//Proportional thrusters with limiters
//Member function of class 'Missile'
//
// parameter input
//		input = commanded input - Nm
//		limiter = max and min value of applied moment - Nm
// return output
//		output = moment about principle axis through c.m. - Nm
//
//040309 Created by Peter H Zipfel
///////////////////////////////////////////////////////////////////////////////

double Missile::rcs_prop(double input,double limiter)
{	
	//local variable
	double output(0);
	output=input;
	if(fabs(input)>limiter)
		output=limiter*sign(input);

	return output;
}

///////////////////////////////////////////////////////////////////////////////
//On-off thrusters modeled by the Schmitt trigger
//Ref: Bryson,A.E.,"Control of Spacecraft and Aircraft", Princeton University Press, 1994
//Switching mechanism with dead-zone and hysteresis, includes also pure hysteresis (dead_zone=0)
// pure dead-zone (hysteresis=0), or simple on/off relay (dead_zone=0,hysteresis=0)
//Member function of class 'Missile'
//
// parameter input
//		input_new = new input value, state variable
//		input = previous input value, saved state variable
//		dead_zone = dead zone of trigger, if zero -> pure hysteresis - units of input
//		hysteresis = hysteresis, if zero -> pure dead zone - units of input
// return output
//		=+/-1: trigger on; =0 trigger off 
//
//040308 Created by Peter H Zipfel
///////////////////////////////////////////////////////////////////////////////

int Missile::rcs_schmitt(double input_new,double input,double dead_zone,double hysteresis)
{	
	//local variable
	int output(0);

	//input signal 'trend' (=1 increasing, =-1 decreasing)
	//input signal 'side' (=-1 left, =1 right)
	int trend=sign(input_new-input);
	int side=sign(input);
	double trigger=(dead_zone*side+hysteresis*trend)/2;

	if(input>=trigger&&side==1){
		output=1;
	}
	else if(input<=trigger&&side==-1){
		output=-1;
	}
	else
		output=0;

	return output;
}